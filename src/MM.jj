/*
/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+

 */
options
{
  static = true;
}

PARSER_BEGIN(Moaz)
import nodes.*;
public class Moaz
{
  public static void main(String args []) throws ParseException
  {
    Moaz parser = new Moaz(System.in);
   	SyntaxTreeNode n = start();
	n.execute(new Context());
  }
}

PARSER_END(Moaz)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN :
{
< PLUS : "+" >
| < SUB : "-" >
| < MULTIPLY : "*" >
| < DIV : "/" >
| < LOG : "log" >
| < SIN : "sin" >
| < COS : "cos" >
| < TAN : "tan" >
| < ABS : "abs" >
| < POWER : "**" >
| < Fact : "!" >

| < LOGICAL: "<" | ">" | "<=" | ">=" | "==" | "!=" >
| < ASSIGN: "=" >
| < SEMI: ";" >
| < COLON: ":" >
| < IF: "if" >
| < ELSE: "else" >
| < FOR: "for" >
| < ARROW: "->" >
| < WHILE: "while" >
| < READ: ">>" >
| < PRINT: "console.log" >  
}


TOKEN :
{
  < LP: "(" >
| < RP: ")" >
| < LB: "{" >
| < RB: "}" >
| < NUM: (["0"-"9"])+("."(["0"-"9"])+)?(("e"|"E")("+"|"-")?(["0"-"9"])+)? >                                                                                                                                                                                                                                                                                                                                                                                                     
| < VAR : (["a"-"z"]|["A"-"Z"]|["$"]|["_"]) (["a"-"z"]|["A"-"Z"]|["0"-"9"]|["$"]|["_"])* >

}
BlockNode start():
{
  BlockNode b;
}
{
    b = block()
    < COLON >
    {
      return b;
    }
}
BlockNode block():
{
  BlockNode b = new BlockNode();
  SyntaxTreeNode n = null;
}
{
  < LB >
  (
    (
      n = SingleOP()
  	) { b.addChild(n); }
  )+
  < RB >
  {
    return b;
  }
}

SyntaxTreeNode SingleOP():
{
  SyntaxTreeNode n;
}
{
	 n = ifstmt() | n = assignstmt() | n = printstmt()
	 {
	   return n ;
	 }
}

WriteNode printstmt():
{
  WriteNode res = new WriteNode();
  SyntaxTreeNode n;
}
{
  < PRINT > < LP > n = E()  < RP >
  {
   	res.addChild(n);
   	return res; 
  }
}


IfNode ifstmt():
{
  IfNode res = new IfNode();
  SyntaxTreeNode c = null;
}
{
  (
	  < IF > < LP > c = condition() < RP >
	  {
	    res.addChild(c);
	  }
	  (		  c = block()
		| c = SingleOP()
      )	  {
	    res.addChild(c);
      }
  )
  (
      < ELSE >
     (
	    c = block()
		| c = SingleOP()
     )
     {
	   res.addChild(c);
	 }
  )?
  {
    return res;
  }
}

ConditionNode condition():
{
  ConditionNode res = new ConditionNode();
  Token t;
  SyntaxTreeNode n1,n2;
}
{
  n1 = E() t = < LOGICAL > n2 = E()
  {
    res.setOperator(t.image);
    res.addChild(n1);
    res.addChild(n2);
    return res;
  }
}

AssignNode assignstmt():
{
  AssignNode res = new AssignNode();
  SyntaxTreeNode n;
  Token t;
}
{
  t = < VAR > <ASSIGN > n = E() < SEMI >
  {
    res.setVariable(t.image);
    res.addChild(n);
    return res;
  }
}
ExpressionNode E():
{
  ExpressionNode n1,n2 = null;
  Token t = null;
}
{
   n1 = F() ( (t = < PLUS >|t = < SUB >) n2 = E())?
   {
     if (t == null)
     	return n1;
     else
     {
       ExpressionNode res = new ExpressionNode();
       res.setOperator(t.image);
       res.addChild(n1);
       res.addChild(n2);
       return res;
     }
   }
}

ExpressionNode F():
{
  ExpressionNode n1,n2 = null;
  Token t = null;
}
{
   n1 = N() ( (t = < MULTIPLY >|t = < DIV >) n2 = F())?
   {
     if (t == null)
     	return n1;
     else
     {
       ExpressionNode res = new ExpressionNode();
       res.setOperator(t.image);
       res.addChild(n1);
       res.addChild(n2);
       return res;
     }
   }
}

ExpressionNode N() :
{
  Token t;
  ExpressionNode e;
}
{
  
  (
    t = < NUM >
    {
		ConstantNode n = new ConstantNode();
		n.setValue(Double.parseDouble(t.image));
		return n;
	}
  )
  | (< LP > e = E() < RP > { return e; })
 	|(
	  t = < VAR >
	  {
	    VariableNode v = new VariableNode();
	    v.setName(t.image);
	    return v;
	  }
	 ) 
//  | x = LOG()
//  | x = SIN()
//  | x = COS()
//  | x = TAN()
//  | x = ABS()

}

//double LOG() :
//{
//  double x;
//}
//{
//  < LOG > < LP > x = E() < RP >
//  {
//    return Math.log(x);
//  }
//}
//
//double SIN() :
//{
//  double x;
//}
//{
//  < SIN > < LP > x = E() < RP >
//  {
//    double teta = (x * Math.PI) / 180.0;
//    double sin = Math.sin(teta);
//    return sin;
//  }
//}
//
//double COS() :
//{
//  double x;
//}
//{
//  < COS > < LP > x = E() < RP >
//  {
//    double teta = (x * Math.PI) / 180.0;
//    double cos = Math.cos(teta);
//    return cos;
//  }
//}
//
//double TAN() :
//{
//  double x;
//}
//{
//  < TAN > < LP > x = E() < RP >
//  {
//    double teta = (x * Math.PI) / 180.0;
//    double tan = Math.tan(teta);
//    return tan;
//  }
//}
//
//double ABS() :
//{
//  double x;
//}
//{
//  < ABS > < LP > x = E() < RP >
//  {
//    return Math.abs(x);
//  }
//}


/*

{
	if(1>2){
		console.log(1)
	}
	else if(2>3){
		console.log(2)
	}
	else
		console.log(3)

*/